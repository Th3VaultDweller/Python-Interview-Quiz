# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'QuizAppGUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import random

from PyQt5 import QtCore, QtGui, QtWidgets

import quiz

# вопросы и ответы будут дублироваться в консоли
from quiz import questions, random_question


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(800, 600)
        self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName("verticalLayout")

        self.ChangeLanguageButton = QtWidgets.QToolButton(Dialog)
        self.ChangeLanguageButton.setAcceptDrops(False)
        self.ChangeLanguageButton.setObjectName("ChangeLanguageButton")
        self.verticalLayout.addWidget(self.ChangeLanguageButton)

        self.Question = QtWidgets.QLabel(Dialog)
        self.Question.setMouseTracking(False)
        self.Question.setAutoFillBackground(True)
        self.Question.setScaledContents(True)
        self.Question.setWordWrap(True)
        self.Question.setObjectName("Question")
        self.verticalLayout.addWidget(self.Question)

        self.Answer = QtWidgets.QLabel(Dialog)
        self.Answer.setAutoFillBackground(True)
        self.Answer.setScaledContents(False)
        self.Answer.setWordWrap(True)
        self.Answer.setOpenExternalLinks(True)
        self.Answer.setObjectName("Answer")
        self.verticalLayout.addWidget(self.Answer)

        self.ShowRandomQuestionButton = QtWidgets.QPushButton(
            Dialog, clicked=lambda: self.ShowRandomQuestion()
        )
        self.ShowRandomQuestionButton.setObjectName("ShowRandomQuestionButton")
        self.verticalLayout.addWidget(self.ShowRandomQuestionButton)

        self.ShowAnswerButton = QtWidgets.QPushButton(
            Dialog, clicked=lambda: self.ShowAnswer()
        )
        self.ShowAnswerButton.setObjectName("ShowAnswerButton")
        self.verticalLayout.addWidget(self.ShowAnswerButton)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.ChangeLanguageButton.setText(_translate("Dialog", "Язык приложения"))
        self.Question.setText(_translate("Dialog", "Вопрос"))
        self.Answer.setText(_translate("Dialog", "Ответ"))
        self.ShowAnswerButton.setText(_translate("Dialog", "Показать ответ"))
        self.ShowRandomQuestionButton.setText(_translate("Dialog", "Случайный вопрос"))

    def ShowRandomQuestion(self):
        """Показать случайный вопрос по нажатию кнопки"""
        random_question = random.choice(questions)
        self.Question.setText(random_question)

    def ShowAnswer(self):
        """Показать ответ на случайный вопрос по нажатию кнопки"""
        if "Что такое Middleware?" in random_question:
            self.Answer.setText(
                "Middleware — это промежуточное программное обеспечение, которое располагается между приложением и сетевыми службами. \nОсновная цель middleware — обработка запросов и ответов между клиентом и сервером."
            )
        if (
            "Какая разница в быстродействии между Django и Flask и почему?"
            in random_question
        ):
            self.Answer.setText(
                "Django чуть медленнее Flask из-за своей более высокой функциональности и накладных расходов. Однако на практике разница в скорости работы между ними незначительна для большинства веб-приложений.\nFlask может быть немного быстрее при обработке простых запросов, но Django лучше масштабируется при увеличении нагрузки благодаря встроенным инструментам кэширования и оптимизации.\nКроме того, производительность в большей степени зависит от архитектуры и качества кода конкретного приложения."
            )
        if "Что такое протоколы?" in random_question:
            self.Answer.setText(
                "Протоколы — это соглашения, которые определяют интерфейс класса и поведение его объектов. Протоколы задаются с помощью специальных методов, таких как str, len и другие. Они позволяют классам работать с различными функциями и операторами языка.\nРеализуя протоколы можно интегрировать классы в языке и делать их поведение естественным и интуитивным. В Python есть протоколы для чисел, итераторов, контекстных менеджеров, атрибутов и других областей. Встроенные и сторонние библиотеки полагаются на стандартные протоколы."
            )

        if (
            "Можно ли объявлять функцию внутри другой функции? Где она будет видна?"
            in random_question
        ):
            self.Answer.setText(
                "Да, функции можно объявлять внутри других функций. Такая вложенная функция будет видна и доступна для вызова только внутри родительской функции, в которой она определена. Это называется замыканием и позволяет ограничить область видимости вложенной функции, чтобы она не загрязняла глобальное пространство имен.\nВложенные функции могут быть полезны, когда нужно реализовать вспомогательную логику, связанную только с работой родительской функции."
            )
        if "Что такое await?" in random_question:
            self.Answer.setText(
                "Await используется для работы с асинхронным кодом и корутинами. Его можно применять только внутри асинхронной функции, определенной с async def.\nAwait позволяет избежать блокировки основного потока программы во время ожидания результатов asynс-функций. Await делает возможным использование асинхронного кода в синхронном стиле последовательно.\nПри вызове await передается управление обратно событийному циклу. Выполнение функции приостанавливается до завершения await-выражения.\nЧаще всего await используется при вызове асинхронных функций и методов — для ожидания результата. Await также может применяться к объектам asyncio.Future и asyncio.Task для ожидания их завершения.\nЕсли await вызывается для корутины, то выполнение текущей корутины приостанавливается до завершения той, которая вызвана."
            )

        if "Что такое async?" in random_question:
            self.Answer.setText(
                "Async — это синтаксис для создания асинхронного кода на основе корутин. Асинхронное программирование позволяет выполнять операции вне основного потока выполнения программы. С помощью async def определяются асинхронные функции-корутины. Такие функции не выполняются сразу, а возвращают объект-корутину. Для запуска корутин используется await. Это передает управление обратно в событийный цикл до завершения корутины.\nAsyncio — стандартный модуль для работы с асинхронным кодом. Он содержит событийный цикл и различные классы. Асинхронный код усложняет логику программы, но позволяет добиться большей производительности за счет неблокирующих вызовов.\nКорутины полезны для операций ввода/вывода, ожидания сети, обращения к БД — там, где нужно не блокировать основной поток."
            )
        # Общие вопросы по Computer Science и Web Development
        if "Что такое инженерия и процесс разработки в целом?" in random_question:
            self.Answer.setText()
        if "Какие знаете принципы программирования?" in random_question:
            self.Answer.setText(
                "1. KISS - Keep It Simple, Stupid. особенно важен для проектов средней сложности. Если вы думаете, что упростили достаточно, упростите код еще на один уровень, но не забывайте начинать с малого, чтобы не создать целую гору проблем.\n2. DRY - Dont Repeat Yorself. Принцип „отсутствия повторов” имеет решающее значение при написании чистого и легко изменяемого кода. При написании кода следует избегать дублирования данных и логики. Если вы заметили, что один и тот же фрагмент кода написан снова и снова, принцип был нарушен. Противоположностью DRY-кода является WET код: «дублируйте». Один из лучших способов диагностики WET-кода – спросить себя: чтобы каким-то образом изменить поведение программы, сколько областей кода нужно было бы изменить?\n3. Open/Closed - код должен быть открытым для внедрения новых областей, но закрытым для изменений, не зависимо от того, пишете вы объекты на Java или модули на Python. Это относится ко всем видам проектов, но этот принцип особенно важен при выпуске библиотек или структур, предназначенных для использования другими пользователями.\n4. Принцип единой ответственности - каждый класс или модуль в программе должен заниматься только одним набором конкретных функций.Классы и модули создаются по этому принципу, но поскольку расширяется функционал, они превращаются с течением времени в классы и модули, которые „могут все” и занимают сотни или даже тысячи строк кода. Если такое произошло, нужно разбить их на более мелкие классы и модули.\n5. Разделение интересов - это принцип единой ответственности, но на более абстрактном уровне. По сути, программа должна быть спроектирована таким образом, чтобы она имела много разных не перекрывающихся инкапсуляций, и эти инкапсуляции не должны взаимодействовать друг с другом.\n6. YAGNI - основывается на том, что вам никогда не нужно реализовывать какую-либо функциональность, которая возможно вам понадобится в будущем. Скорее всего, вам это не понадобится, и это будет пустая трата времени, это также усложнит ваш код. Часто неопытные программисты пытаются написать наиболее абстрактный и общий код, чтобы избежать WET код, но слишком большая абстракция заканчивается тем, что его невозможно поддерживать в будущем. Хитрость заключается в том, чтобы применять принцип DRY только тогда, когда вам нужно.\n7. Избежание преждевременной оптимизации - принцип избежания преждевременной оптимизации не похож на принцип YAGNI. Разница в том, что YAGNI предотвращает внедрение функций до того, как они понадобятся, в то время как принцип избежания преждевременной оптимизации направлен на предотвращение оптимизации  работы алгоритмов, прежде чем это будет необходимо. Проблема с преждевременной оптимизацией заключается в том, что вы никогда не сможете узнать, где будут проблемы в программе до тех пор, пока они не проявятся. Разумеется, вы можете догадаться, и иногда вы даже можете быть правы. Но чаще всего вы будете тратить драгоценное время, пытаясь ускорить процессы, которые не так уж и медленны, как вы думаете. \n8. Рефакторинг - одна из самых сложных истин для неопытного программиста заключается в том, что очень редко с первого раза все заработает. Вы можете подумать, что написали идеальный код, реализуя определенную функцию, но по мере того, как ваша программа будет усложняться, написание будущих функций может быть довольно сложным, так как вы реализовали определенную функцию на ранней стадии. Кодовые базы постоянно развиваются. Совершенно нормально пересматривать, переписывать или даже перепроектировать целые фрагменты кода – и это не просто нормально, это правильно. Ведь позже вы будете знать больше о специфике вашего проекта, чем в начале его создания, поэтому вы должны постоянно реорганизовывать свой старый код. И не откладывайте это место на потом. Как только вы поняли, что где-то есть ошибка, не откладывайте ее исправление.  Если вам когда-нибудь понадобится проверить или исправить старый код, постарайтесь улучшить его и сделать более чистым и аккуратным.\n9. Чистый код > Умный код - говоря о чистом коде, оставьте где-то далеко своё этот „умный” код. Под умным кодом подразумевается тип кода, который больше похож на загадку, чем на решение, и существует только для того, чтобы показать, насколько вы умны. На самом деле, никого это не волнует. Примером „умного кода” будет вместить как можно больше логики в одну строку. Другим примером является использование специфических особенностей языка для написания странных, но работающих операций. Примером умного кода будет все то, что может заставить кого-то сказать «Погоди, что это?» при просмотре вашего кода. Хороший программист и читаемый код идут рука об руку. Делайте комментарии при такой необходимости. Придерживайтесь определенного стиля, независимо от того, диктуется ли он языком (например, Python) или компанией (например, Google). Наблюдайте за языковыми идиомами и прекратите писать Java-код на Python или наоборот."
            )

        if (
            "Чем отличаются процедурная и объектно-ориентироавнная парадигмы программирования?"
            in random_question
        ):
            self.Answer.setText(
                "ООП или Объе́ктно-ориенти́рованное программи́рование хорошо применяется в практике программирования для более лёгкого создания управляемых проектов. Процедурный подход подразумевает написание программного кода без использования объектов. Процедурное программирование заключается в написании кода с или без подпрограмм."
            )

        if (
            "Какие основные принципы ООП (наследование, инкапсуляция, полиморфизм)?"
            in random_question
        ):
            self.Answer.setText(
                "Абстракция — отделение концепции от ее экземпляра;\nПолиморфизм — реализация задач одной и той же идеи разными способам;\nНаследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;\nИнкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним."
            )
        if "Что такое множественное наследование?" in random_question:
            self.Answer.setText(
                "Множественное наследование — это возможность класса иметь более одного родительского класса. При множественном наследовании дочерний класс наследует все свойства родительских классов. Синтаксис множественного наследования очень похож на синтаксис обычного наследования."
            )

        if (
            "Какие есть шесть этапов разработки продукта в Software Development lifecycle и какая разница между Agile и Kanban?"
            in random_question
        ):
            self.Answer.setText()
        if (
            "Какие есть методы HTTP-запросов и какая между ними разница?"
            in random_question
        ):
            self.Answer.setText(
                'GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.\nHEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.\nPOST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.\nPUT заменяет все текущие представления ресурса данными запроса.\nDELETE удаляет указанный ресурс.\nCONNECT устанавливает "туннель" к серверу, определённому по ресурсу.\nOPTIONS используется для описания параметров соединения с ресурсом.\nTRACE выполняет вызов возвращаемого тестового сообщения с ресурса.\nPATCH используется для частичного изменения ресурса.'
            )

        if "Что такое авторизация и как она работает?" in random_question:
            self.Answer.setText()

        if "Что такое cookies?" in random_question:
            self.Answer.setText(
                "Куки (cookies) — это хранящиеся на компьютерах и гаджетах небольшие файлы, c помощью которых сайт запоминает информацию о посещениях пользователя. Благодаря кукам при каждом посещении того или иного ресурса не нужно вводить регистрационные данные — браузер их подгружает самостоятельно. Поэтому нагрузка не сервер не возрастает и повышается скорость открытия веб-страниц. Сами по себе куки не опасны — это обычные текстовые файлы. Они не могут запускать какие-либо процессы на компьютере и каким-то образом влиять на работу операционной системы."
            )
        if "Что такое веб-уязвимость?" in random_question:
            self.Answer.setText()
        if "Какие знаете классические базы данных?" in random_question:
            self.Answer.setText()
        if (
            "Как читать спецификацию в конкретном языке (например, PEP8 в Python)?"
            in random_question
        ):
            self.Answer.setText()
        if "Как происходит взаимодействие клиента и сервера?" in random_question:
            self.Answer.setText()

        if "Какие есть подходы к проектированию API?" in random_question:
            self.Answer.setText()

        if "Как использовать паттерны программирования?" in random_question:
            self.Answer.setText()

        if "Что такое Acceptance Testing и зачем его используют?" in random_question:
            self.Answer.setText()

        if "Что такое модульные и интеграционные тесты, API-тесты?" in random_question:
            self.Answer.setText()

        if "Как писать unit-тесты?" in random_question:
            self.Answer.setText()

        if "Какие есть best practices в написании автотестов?" in random_question:
            self.Answer.setText()

        if "Какие базовые команды системы контроля версий?" in random_question:
            self.Answer.setText()

        if "Как использовать Git?" in random_question:
            self.Answer.setText()

        if "В чем разница между хешированием и шифрованием?" in random_question:
            self.Answer.setText()
        # Python
        if "Python - интерпретируемый язык или компилируемый?" in random_question:
            self.Answer.setText(
                "Это интерпретируемый язык, а не компилируемый, как C++ или Java. Программа на Python представляет собой обычный текстовый файл. Код можно писать практически в любом редакторе или использовать специальные IDE: PyCharm — мощная среда разработки от JetBrains."
            )

        if "Какие есть меняющиеся и постоянные типы данных?" in random_question:
            self.Answer.setText(
                "Неизменяемые типы данных: целые числа (int), строки (str), кортежи (tuple), числа с плавающей запятой (float).\nИзменяемые типы данных: списки (list), словари (dict)."
            )

        if "Что такое область видимости переменных?" in random_question:
            self.Answer.setText(
                "Область видимости или scope определяет контекст переменной, в рамках которого ее можно использовать. В Python есть два типа контекста: глобальный и локальный.\nГлобальный контекст подразумевает, что переменная является глобальной, она определена вне любой из функций и доступна любой функции в программе.\nВ отличие от глобальных переменных локальная переменная определяется внутри функции и доступна только из этой функции, то есть имеет локальную область видимости."
            )

        if "Что такое introspection?" in random_question:
            self.Answer.setText(
                "Интроспекция — это способность объекта во время выполнения получить тип, доступные атрибуты и методы, а также другую информацию, необходимую для выполнения дополнительных операций с объектом."
            )

        if "Разница между is и ==?" in random_question:
            self.Answer.setText(
                "Важно помнить об этой разнице при работе с Python. Особенно это актуально при работе с изменяемыми типами данных, такими как списки или словари, где «==» и «is» могут дать совершенно разные результаты.\n«==» сравнивает значения, а «is» проверяет, указывают ли объекты на одну и ту же область памяти."
            )

        if "Разница между __init __ () и __new __ ()?" in random_question:
            self.Answer.setText()

        if "В чем разница между потоками и процессами?" in random_question:
            self.Answer.setText()

        if "Какие есть виды импорта?" in random_question:
            self.Answer.setText()

        if "Что такое класс, итератор, генератор?" in random_question:
            self.Answer.setText()

        if "Что такое метакласс, переменная цикла?" in random_question:
            self.Answer.setText()

        if "В чем разница между итераторами и генераторами?" in random_question:
            self.Answer.setText()

        if "В чем разница между staticmethod и classmethod?" in random_question:
            self.Answer.setText()

        if "Как работают декораторы, контекстные менеджеры?" in random_question:
            self.Answer.setText()

        if (
            "Как работают dict comprehension, list comprehension и set comprehension?"
            in random_question
        ):
            self.Answer.setText()

        if (
            "Можно ли использовать несколько декораторов для одной функции?"
            in random_question
        ):
            self.Answer.setText()

        if "Можно ли создать декоратор из класса?" in random_question:
            self.Answer.setText(
                "Да. Если decorator является классом, он должен принимать функцию func в качестве аргумента в своем методе __init__(). Кроме того, класс должен быть вызываемым, чтобы он мог выступать в качестве декоратора функции."
            )

        if (
            "Какие есть основные популярные пакеты (requests, pytest, etc)?"
            in random_question
        ):
            self.Answer.setText()

        if "Что такое lambda-функции?" in random_question:
            self.Answer.setText(
                "Лямбда-выражение в программировании — специальный синтаксис для определения функциональных объектов, заимствованный из λ-исчисления. Применяется как правило для объявления анонимных функций по месту их использования, и обычно допускает замыкание на лексический контекст, в котором это выражение использовано."
            )

        if "Что означает *args, **kwargs и как они используются?" in random_question:
            self.Answer.setText()

        if "Что такое exceptions, <try-except>?" in random_question:
            self.Answer.setText()

        if (
            "Что такое PEP (Python Enhancement Proposal), какие из них знаете (PEP 8, PEP 484)?"
            in random_question
        ):
            self.Answer.setText()

        if (
            "Какие есть типы данных и какая разница между list и tuple, зачем они?"
            in random_question
        ):
            self.Answer.setText()

        if (
            "Как использовать встроенные коллекции (list, set, dictionary)?"
            in random_question
        ):
            self.Answer.setText()

        if "В чем заключается сложность доступа к элементам dict?" in random_question:
            self.Answer.setText()

        if (
            "Как создается объект в Python, для чего __new__, зачем __init__?"
            in random_question
        ):
            self.Answer.setText()

        if (
            "Что такое шаблонизатор и как в нем выполнять базовые операции (объединять участки шаблона, выводить дату, выводить данные с серверной стороны)?"
            in random_question
        ):
            self.Answer.setText()

        if "Как Python работает с HTTP-сервером?" in random_question:
            self.Answer.setText()

        if "Что происходит, когда создается виртуальная среда?" in random_question:
            self.Answer.setText()

        if "Что такое модель памяти Python?" in random_question:
            self.Answer.setText()

        if (
            "Что такое SQLAlchemy (Core и ORM частей) и какие есть альтернативы?"
            in random_question
        ):
            self.Answer.setText()

        if (
            "Принципы работы и механизм Garbage collection, reference counting?"
            in random_question
        ):
            self.Answer.setText()

        if "Как работает thread locals?" in random_question:
            self.Answer.setText()

        if "Что такое _slots_?" in random_question:
            self.Answer.setText()

        if (
            "Как передаются аргументы функций в Python (by value or reference)?"
            in random_question
        ):
            self.Answer.setText()

        if "Что такое type annotation?" in random_question:
            self.Answer.setText()

        if (
            "Для чего используют нижние подчеркивания в именах классов?"
            in random_question
        ):
            self.Answer.setText()

        if (
            "Каким образом можно запустить код на Python параллельно?"
            in random_question
        ):
            self.Answer.setText()

        if "Как работать с stdlib?" in random_question:
            self.Answer.setText()

        if "Что такое дескрипторы?" in random_question:
            self.Answer.setText()
        # Базы данных
        if (
            "Какие есть базовые методы работы с SQL- базой данных в Python?"
            in random_question
        ):
            self.Answer.setText()

        if "Что такое SQL-транзакция?" in random_question:
            self.Answer.setText()

        if "Как сделать выборку из SQL-базы с простой агрегацией?" in random_question:
            self.Answer.setText()

        if (
            "Как выглядит запрос, который выполняет JOIN между таблицами и к самим себе?"
            in random_question
        ):
            self.Answer.setText()

        if "Как отправлять запросы в SQL-базу данных без ORM?" in random_question:
            self.Answer.setText()

        if "Разница между SQL и NoSQL?" in random_question:
            self.Answer.setText()

        if "Как оптимизировать SQL-запросы?" in random_question:
            self.Answer.setText()

        if "Какие есть уровни изоляции транзакций?" in random_question:
            self.Answer.setText()

        if "Какие есть виды индексов?" in random_question:
            self.Answer.setText()

        if (
            "Работали ли с Docker-контейнерами, объяснить основные термины K8s (кластер, pod, node, deployment, service), что такое Kibana?"
            in random_question
        ):
            self.Answer.setText()
        # Алгоритмы
        if "Что такое алгоритмы (например, Big-O notation)?" in random_question:
            self.Answer.setText(
                "Алгоритм - приводящая к решению задач последовательность действий.\nBig O нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени."
            )

        if "Какие есть базовые алгоритмы сортировки?" in random_question:
            self.Answer.setText(
                "Пузырьковая сортировка (Bubble Sort). Этот вид сортировки изучают в начале знакомства с дисциплиной Computer Science, поскольку он максимально просто демонстрирует саму концепцию сортировки. При этом подходе осуществляется перебор по списку и сравнение соседних элементов. Они меняются местами в том случае, если порядок неправильный. Так продолжается до тех пор, пока все элементы не расположатся в нужном порядке. Из-за большого количества повторений у пузырьковой сортировки его сложность в худшем случае — O(n^2).\nСортировка с выбором (Selection Sort). Сортировка выбором — также простой алгоритм, но более эффективный по сравнению с пузырьковой сортировкой. В большинстве случаев сортировка выбором будет более удачным выбором из двух.В этом алгоритме список (или массив) делится на две части: список с отсортированными элементами и список с элементами, которые только нужно сортировать. Сначала ищется самый маленький элемент во втором. Он добавляется в конце первого. Таким образом алгоритм постепенно формирует список от меньшего к большему. Так происходит до тех пор, пока не будет готовый отсортированный массив.\nСортировка вставками (Insertion Sort). Сортировка вставками быстрее и проще двух предыдущих. Именно так большинство людей тасует карты любой игре. На каждой итерации программа берет один из элементов и подыскивает для него место в уже отсортированном списке. Так происходит до тех пор, пока не останется ни одного неиспользованного элемента.\nСортировка слиянием (Merge Sort). Сортировка слиянием — элегантный пример использования подхода «Разделяй и властвуй». Он состоит из двух этапов: Несортированный список последовательно делится на N списков, где каждый включает один «несортированный» элемент, а N — это число элементов в оригинальном массиве. Списки последовательно сливаются группами по два, создавая новые отсортированные списки до тех пор, пока не появится один финальный отсортированный список.\nБыстрая сортировка (Quick Sort). Как и сортировка слиянием, быстрая сортировка использует подход «Разделяй и властвуй». Алгоритм чуть сложнее, но в стандартных реализациях он работает быстрее сортировки слиянием, а его сложность в худшем случае редко достигает O(n^2). Он состоит из трех этапов: Выбирается один опорный элемент. Все элементы меньше опорного перемешаются слева от него, остальные — направо. Это называется операцией разбиения. Рекурсивно повторяются 2 предыдущих шага к каждому новому списку, где новые опорные элементы будут меньше и больше оригинального соответственно."
            )

        if "Что такое Bubble Sort и как это работает?" in random_question:
            self.Answer.setText(
                "Пузырьковая сортировка (Bubble Sort). Этот вид сортировки изучают в начале знакомства с дисциплиной Computer Science, поскольку он максимально просто демонстрирует саму концепцию сортировки. При этом подходе осуществляется перебор по списку и сравнение соседних элементов. Они меняются местами в том случае, если порядок неправильный. Так продолжается до тех пор, пока все элементы не расположатся в нужном порядке. Из-за большого количества повторений у пузырьковой сортировки его сложность в худшем случае — O(n^2)."
            )

        if "Что такое линейная сложность сортировки?" in random_question:
            self.Answer.setText()
        # Middle вопросы
        if "Что такое многопоточность?" in random_question:
            self.Answer.setText(
                "Многопото́чность (англ. Multithreading) — свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени."
            )

        if "Что такое архитектура веб-сервисов?" in random_question:
            self.Answer.setText()

        if "Как написать, задеплоить и поддерживать (микро) сервис?" in random_question:
            self.Answer.setText()

        if "Как масштабировать API?" in random_question:
            self.Answer.setText()

        if "Как проводить Code review?" in random_question:
            self.Answer.setText(
                "Code-review — процесс итерационный и на каждой итерации происходит следующее: \n1.Автор делится кодом \n2.Ревьювер смотрит код, формирует фидбек и отправляет его автору \n3.Автор реагирует на фидбек уточняющими комментариями или изменениями в коде и снова отдает код на ревью."
            )

        if (
            "Что такое абстрактная фабрика, как ее реализовать и зачем ее применяют?"
            in random_question
        ):
            self.Answer.setText()

        if "Что такое цикломатическая сложность?" in random_question:
            self.Answer.setText(
                "Цикломатическая сложность -показатель сложности исходного кода программы, который связан (коррелирует) с вероятностью возникновения ошибок (багов) в программе. Большая цикломатическая сложность программы (модуля) как правило означает запутанность кода, и повышение риска ошибок при модификации кода."
            )

        if (
            "Что такое временная сложность алгоритма (time complexity)?"
            in random_question
        ):
            self.Answer.setText(
                "Временная сложность алгоритма (в худшем случае) — это функция размера входных и выходных данных, равная максимальному количеству элементарных операций, проделываемых алгоритмом для решения экземпляра задачи указанного размера. Во многих задачах размер выхода не превосходит или пропорционален размеру входа — в этом случае можно рассматривать временную сложность как функцию размера только входных данных. Аналогично понятию временной сложности в худшем случае определяется понятие временная сложность алгоритма в наилучшем случае. Также рассматривают понятие среднее время работы алгоритма, то есть математическое ожидание времени работы алгоритма. Иногда говорят просто: «Временная сложность алгоритма» или «Время работы алгоритма», имея в виду временную сложность алгоритма в худшем, наилучшем или среднем случае (в зависимости от контекста)."
            )


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())
